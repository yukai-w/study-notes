# diff

diff作为virtual DOM 的加速器, 其算法上的改进优化是React整个界面渲染的基础和性能的保障, 同时也是React源码中最神秘,最不可思议的部分.

> Virtual DOM 模型与diff是保证React性能口碑的幕后推手.

## 传统diff算法

计算一棵树形结构转换成另一棵树形结构的最少操作, 是一个复杂且值得研究的问题.

传统的diff算法通过`循环递归`对节点进行一次对比, 效率低下

## 详解diff

React将Virtual DOM树转换成actual DOM树的最少操作的过程称为`调和(reconciliation)`.

> React通过制定大胆的策略, 将O(n^3)复杂度的问题转换成O(n)复杂度的问题.

### diff策略

1. Web UI中DOM节点跨层级的移动操作特别少, 可以忽略不计.
2. 拥有相同类的两个组件将生成相似的树形结构, 拥有不同类的两个组件将会生成不同的树形结构.
3. 对于同一层级的一组子节点, 它们可以通过唯一id进行区分.

### tree diff

基于策略一, React对树的算法进行了简洁明了的优化, 即对树进行分层比较, 两棵树只会`对同一层次的节点进行比较`.

> 在开发组件的时候, 保持稳定的DOM结构会有助于性能的提升. 例如: 可以通过css隐藏或显示节点, 而不是真正地移除或添加DOM节点.

### component diff

React是基于组件构建应用的, 对于组件间的比较所采取的策略也是非常简洁,搞笑的:
- 如果是同一类型的组件, 按照原策略继续比较Virtual DOM树即可;
- 如果不是, 则将该组件判断为dirty component, 从而替换整个组件下的所有子节点;
- 对于同一类型的组件, 有可能其Virtual DOM没有任何变化, 如果能够确切知道这点, 那么就可以节省大量的diff运算时间. 因此, React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析.

### element diff

当节点出于同一层时, diff提供了3种节点操作, 分别为`INSERT_MARKUP(插入)`, `MOVE_EXISTING(移动)`和`REMOVE_NODE(删除)`.
- 插入: 新的组件类型不在旧集合里, 即全新的节点, 需要对新节点执行插入操作.
- 移动: 旧集合中有新组件类型, 且element是可更新的类型, 这种情况下prevChild=nextChild, 就需要做移动操作, 可以复用以前的DOM节点.
- 删除: 旧组件类型, 在新集合里也有, 但对应的element不同则不能直接复用和更新, 需要执行删除操作, 或者旧组件不在新集合里的, 也需要执行删除操作.

> 在移动前需要将当前节点在旧集合中的位置与lastIndex进行比较`if(child._mountIndex < lastIndex)`, 否则不执行该操作.这是一种顺序优化手段.

## React Patch 方法

所谓Patch, 简而言之就是将tree diff计算出来的DOM差异队列更新到真实的DOM节点上, 最终让浏览器能够渲染出更新的数据.